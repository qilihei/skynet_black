{"version":3,"sources":["file:///E:/skynet_game_server/skynet_black/client/assets/scripts/managers/EventManager.ts"],"names":["_decorator","ccclass","EventManager","getInstance","instance","constructor","eventMap","Map","on","event","callback","target","has","set","callbacks","get","bind","push","once","onceCallback","args","apply","off","index","indexOf","splice","length","delete","emit","callbacksCopy","error","console","hasListener","getListenerCount","clear","getEventNames","Array","from","keys"],"mappings":"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","sourcesContent":["import { _decorator } from 'cc';\n\nconst { ccclass } = _decorator;\n\nexport type EventCallback = (...args: any[]) => void;\n\n@ccclass('EventManager')\nexport class EventManager {\n    private static instance: EventManager;\n    private eventMap: Map<string, EventCallback[]> = new Map();\n    \n    public static getInstance(): EventManager {\n        if (!EventManager.instance) {\n            EventManager.instance = new EventManager();\n        }\n        return EventManager.instance;\n    }\n    \n    private constructor() {}\n    \n    // 注册事件监听\n    public on(event: string, callback: EventCallback, target?: any): void {\n        if (!this.eventMap.has(event)) {\n            this.eventMap.set(event, []);\n        }\n        \n        const callbacks = this.eventMap.get(event)!;\n        \n        // 绑定目标对象\n        if (target) {\n            callback = callback.bind(target);\n        }\n        \n        callbacks.push(callback);\n    }\n    \n    // 注册一次性事件监听\n    public once(event: string, callback: EventCallback, target?: any): void {\n        const onceCallback = (...args: any[]) => {\n            callback.apply(target, args);\n            this.off(event, onceCallback);\n        };\n        \n        this.on(event, onceCallback);\n    }\n    \n    // 移除事件监听\n    public off(event: string, callback?: EventCallback): void {\n        if (!this.eventMap.has(event)) {\n            return;\n        }\n        \n        const callbacks = this.eventMap.get(event)!;\n        \n        if (callback) {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1) {\n                callbacks.splice(index, 1);\n            }\n        } else {\n            // 移除所有监听\n            callbacks.length = 0;\n        }\n        \n        // 如果没有监听器了，删除事件\n        if (callbacks.length === 0) {\n            this.eventMap.delete(event);\n        }\n    }\n    \n    // 触发事件\n    public emit(event: string, ...args: any[]): void {\n        if (!this.eventMap.has(event)) {\n            return;\n        }\n        \n        const callbacks = this.eventMap.get(event)!;\n        \n        // 复制数组，避免在回调中修改原数组导致问题\n        const callbacksCopy = [...callbacks];\n        \n        for (const callback of callbacksCopy) {\n            try {\n                callback(...args);\n            } catch (error) {\n                console.error(`Error in event callback for '${event}':`, error);\n            }\n        }\n    }\n    \n    // 检查是否有监听器\n    public hasListener(event: string): boolean {\n        return this.eventMap.has(event) && this.eventMap.get(event)!.length > 0;\n    }\n    \n    // 获取监听器数量\n    public getListenerCount(event: string): number {\n        return this.eventMap.has(event) ? this.eventMap.get(event)!.length : 0;\n    }\n    \n    // 清除所有事件监听\n    public clear(): void {\n        this.eventMap.clear();\n    }\n    \n    // 获取所有事件名称\n    public getEventNames(): string[] {\n        return Array.from(this.eventMap.keys());\n    }\n}\n"]}